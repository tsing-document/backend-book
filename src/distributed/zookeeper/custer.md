---
title: 【第七篇章】集群搭建
index: false
isOriginal: true
category: "分布式技术"
tag: "zookeeper"
date: 2024-07-31
---


## 一、概述

1、集群中的角色
::: tabs

@tab:active Leader

Zookeeper集群工作的核心，事务请求（写操作）唯一调度和处理者，保证集群事务处理的顺序性；集群内部各个服务的调度者。对于 **create、setData、delete**等有些操作的请求，则需要统一转发给Leader处理，Leader需要决定编号、执行操作，这个过程称为一个事务。

@tab Follower

处理客户端非事务（读操作）请求，转发事务请求给Leader, 参与Leader选取投票。  

@tab Observer

观察者角色，观察zookeeper集群的最新状态变化并将状态同步过来，其对于非事务的请求可以进行独立处理，对于事务请求，则会转发给Leader服务器处理，不会参数任何形式的投票只提供服务，其实就是增加非事务的并发量。

:::

2、集群为什么要搭建奇数个节点
- 如果部署单个节点，当节点宕机时，集群就会失效，就会出现单点故障。
- 如果部署两个节点，2的半数为1，半数以上最少为2，不允许有一台机器故障，不然投票机制不成立。
- 如果部署三个节点，3的半数为1.5，半数以上最少为2，允许有一台机器故障，投票机制可以成立。
- 如果部署四个节点，4的半数为2，半数以上最少为3，允许有一台机器机器故障，投票机制可以成立。
- 如果部署五个节点，5的半数为2.5，半数以上最少为3，允许有两台机器故障，投票机制可以成立。
- 所以部署zookeeper集群的时候一般部署的节点数量为`2n+1`台节点。

## 二、集群选取机制
1、节点状态

| 名称 |  描述  |
| --- | --- |
| Looking | 这个是在选举的过程中的状态，正在选举。|
| Leading | 领导者状态，说明当前节点角色已经是Leader。|
| Following | 跟随者状态，表示选举已经完成，当前角色已经是Following。|
| Oberver | 观察者状态，表示当前节点角色是observer。|

2、事务ID

Zookeeper状态每次变化都接收一个`ZXID`（zookeeper事务id）形式的标记，由Leader统一分配，全局唯一，不断递增。

3、初始化选取过程

由三个节点举例：当`第一个节点`启动的时候，因为单节点无法进行选举，所以当`第二个节点`启动之后，两台机器之间可以互相通信了，开始选举过程：

- 1、两个节点都当自己是 Leader 角色来投票，每次投票都包含服务器配置的 `myid`（下文中能找到myid）中的值和 `ZXID`。使用`(myid, zxid)` 表示，此时第一个节点为 `(1, 0)`，第二个节点为 `(2, 0)`，然后将自己的值发给其他节点。
- 2、当其他服务收到投票后，先判断是否是本轮投票，投票的机器的状态是否为 `Looking`。
- 3、针对每次的投票，服务器都需要将自己的票数和其他服务器对比。先检查 `ZXID`，这个时候 `ZXID` 都为0，如果 `ZXID` 谁的大谁就是Leader，如果 `ZXID` 相同就对比 `myid`，第二个节点的 `myid` 为2，所以第二个节点就是Leader。
- 4、每次投票之后，服务器会统计是否有过半的机器接收到相同的投票信息，如果已经过半，就确认第二个节点为 Leader。
- 5、一旦确认了 Leader，每台服务器都会更新自己的状态。如果是 `Follower` 角色，就改变状态为` Following`，如果是 `Leader` 角色，就改变状态为 `Leading`。当 `第三个节点` 进来的发现已经有了 Leader, 状态直接变成 `Following`。

4、运行状态下选举

以下当第二个节点故障，第一个节点和第三个节点是良好的节点。

- 1、当 Leader 挂掉之后，集群会拒绝所有的服务，余下非 `Observer` 服务器都会将自己的服务器的状态变更为 `Looking`。然后开始选举。
- 2、每个节点会发出投票。运行期间，节点上的 `ZXID` 可能不同，假设：第一个节点的 `ZXID` 为100，第三个节点的 `ZXID` 为120，这个时候第一个节点和第三个节点都会投票自己，第一个节点为 `(1, 100)`，第三个节点为 `(3, 120)`，由于第三个节点的 `ZXID` 为120，直接选举为 Leader。
- 3、其他步骤和初始化启动的时候一样。