---
title: ☕ 面试题总结(上) 
index: false
isOriginal: true
category: "面试宝典"
tag: "java"
date: 2024-08-12
---
## 一、Java 中有几种基本数据类型？各占多少字节？

在 Java 中基本数据类型有 8 个，占用的字节分别是整型 byte（1个字节）、short（2个字节）、int（4个字节）、long（8个字节）；浮点型 float（4个字节）、double（8个字节）；布尔类型 boolean； 字符类型 char (2个字节)。

## 二、String 类能被继承吗？为什么？

String 类不能被继承。因为 String 类被 final 修饰。final 修饰变量变量就会变成常量；final 修饰方法方法就会不可重写；final 修饰类类就不能继承；

## 三、String、StringBuilder、StringBuffer 的区别？

String 是只读字符串，也就是说 String 引用的字符串内容是不能被改变的。

StringBuffer/StringBuilder 类表示字符串对象可以直接修改。

StringBuffer 是线程安全的效率慢。StringBuilder 是线程不安全的效率高。

## 四、equals 和 hashcode

1、简述 `hashCode()` 和 `equals(Object obj)` 的作用及其关系

`hashCode()` 方法用于获取对象的哈希码，即一个整数。这个哈希码在基于哈希的集合（如HashSet、HashMap等）中用于确定对象的存储位置。

`equals(Object obj)` 方法用于比较两个对象是否相等。默认情况下，它比较的是对象的引用地址；但在自定义类中，通常会重写该方法以比较对象的内容。

这两个方法之间的关系是：如果两个对象通过 `equals(Object obj)` 方法比较是相等的，那么调用这两个对象中任一对象的 `hashCode()` 方法必须产生相同的整数结果。这是Java集合框架正常工作的基本要求。

2、为什么要在自定义类中同时重写 `hashCode()` 和 `equals(Object obj)` 方法？

如果只重写 `equals(Object obj)` 方法而不重写 `hashCode()` 方法，那么在基于哈希的集合中，即使两个对象通过 `equals(Object obj)` 方法比较是相等的，但由于它们的哈希码不同，这些集合也可能无法正确地处理它们（如无法正确去重）。

因此，为了保证自定义对象在Java集合框架中的正确性，当重写 `equals(Object obj)` 方法时，通常也需要重写 `hashCode()` 方法，以确保 `equals(Object obj)` 相等的对象具有相同的哈希码。

3、请解释为什么`hashCode()`方法可能产生哈希碰撞，以及这是否会影响`equals(Object obj)`方法的正确性？
   
哈希碰撞是指不同的对象产生相同的哈希码。由于哈希码是一个整数，而整数的范围是有限的，而对象的数量可以是无限的，因此哈希碰撞是不可避免的。

哈希碰撞本身不会影响 `equals(Object obj)` 方法的正确性。`equals(Object obj)` 方法用于比较对象的内容是否相等，而哈希码只是用于在集合中快速定位对象的一种机制。即使两个对象产生了哈希碰撞，只要它们的 `equals(Object obj)` 方法比较不相等，它们就不会被视为集合中的相同元素。

然而，哈希碰撞可能会影响基于哈希的集合的性能，因为它可能增加在集合中查找元素的时间复杂度。

4、在重写 `hashCode()` 方法时，有哪些注意事项？

在重写`hashCode()`方法时，应该确保在同一个Java应用程序执行期间，只要对象的equals比较中所用的信息没有被修改，那么对该对象多次调用hashCode方法必须始终如一地返回同一个整数。

如果两个对象通过 `equals(Object obj)` 方法比较是相等的，那么这两个对象的 `hashCode()` 方法必须产生相同的整数结果。

不要求如果两个对象通过 `equals(Object obj)` 方法比较是不相等的，那么调用这两个对象中任一对象的 `hashCode()` 方法必须产生不同的整数结果。但是，为不相等的对象产生不同整数结果可能会提高哈希表的性能。

## 五、抽象类和接口有什么区别？

抽象类和接口都不能够实例化，但是可以定义抽象和接口类型的引用。一个类如果继承了某个抽象类或者实现某个接口都需要对其中的抽象方法进行实现，否则该类仍然需要被声明为抽象类。

接口比抽象类更加抽象，因为抽象类中可以定义构造器，可以有抽象方法和具体方法，而接口中不能定义构造器而且其中的方法全部是抽象方法。

## 六、在多线程情况下 SimpleDateFormat 是线程安全的吗？

在多线程情况下 DateFormat 的所有实现，包括 SimpleDateFormat 都不是线程安全的。如果不在线程安全的情况下使用，在解析或者格式化日期的时候，可能会会获得一个不正确的结果。最佳的时间的多线程的情况下使用的时间工具类是 `joda-time`。

## 七、抽象类是什么？它和接口有啥区别？

接口用于规范，抽象类用于共性。声明方法的存在而不去实现它的类叫做抽象类。接口时抽象类的变体。在接口中，所有的方法都是抽象的。

## 八、讲讲类的实例化顺序，比如父类静态数据，构造函数，字段，子类静态数据，构造函数，字段，当new的时候，他们的执行顺序

在Java中，当使用`new`关键字创建一个类的实例时，会遵循一个特定的顺序来初始化对象。这个顺序涉及到父类和子类的静态数据、构造函数以及字段（成员变量）的初始化。下面是这个顺序的详细解释：

1、**静态块和静态变量（父类到子类）**：
- 首先，会初始化父类中定义的静态变量和静态初始化块（如果有的话），按照它们在代码中出现的顺序进行。
- 然后，会初始化子类中定义的静态变量和静态初始化块（如果有的话），也是按照它们在代码中出现的顺序进行。
- 需要注意的是，静态初始化只会在类被加载到JVM时发生一次，与创建类的实例数量无关。

2、**实例变量（父类到子类）**：
- 在创建类的实例时，会首先为父类中的实例变量分配内存并默认初始化（例如，数值类型变量初始化为0，对象引用初始化为null）。
- 然后，会执行父类的非静态初始化块（如果有的话）。
- 接着，会执行父类的构造函数，此时父类的实例变量可以被显式初始化。
- 同样的过程会发生在子类上，但会在父类初始化之后进行。子类中的实例变量会被分配内存并默认初始化，然后执行子类的非静态初始化块（如果有的话），最后执行子类的构造函数。

3、**构造函数（父类到子类）**：
- 在创建对象时，构造函数的调用是遵循从父类到子类的顺序的。这意味着在子类的构造函数中，可以通过`super()`（显式或隐式）调用父类的构造函数，并且这个调用必须是子类构造函数中的第一条语句（除了注释和变量声明）。
- 如果子类没有显式调用父类的构造函数，则会自动调用父类的无参构造函数（如果父类没有定义无参构造函数且子类没有显式调用其他构造函数，则会导致编译错误）。

综上所述，当使用`new`关键字创建类的实例时，执行顺序大致如下：

1、父类静态变量和静态初始化块（按出现顺序）。
2、子类静态变量和静态初始化块（按出现顺序）。
3、父类实例变量默认初始化。
4、父类非静态初始化块（如果有的话）。
5、父类构造函数。
6、子类实例变量默认初始化。
7、子类非静态初始化块（如果有的话）。
8、子类构造函数。

这个顺序确保了父类在子类之前被完全初始化，从而保证了继承体系中的正确性和稳定性。