import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as t,a as l,o as a}from"./app-ioGy9IPI.js";const s="/backend-book/assets/shuangxianglist-u_trRoLP.jpg",n={};function o(d,e){return a(),t("div",null,e[0]||(e[0]=[l('<h2 id="一、数组和链表" tabindex="-1"><a class="header-anchor" href="#一、数组和链表"><span>一、数组和链表</span></a></h2><p>1、数组</p><p>数组会在内存中开辟一块连续的空间存储数据，这种存储方式有利也有弊端。当获取数据的时候，直接通过下标值就可以获取到对应的元素，时间复杂度为 <code>O(1)</code>。但是如果新增或者删除数据会移动大量的数据，时间复杂度为 <code>O(n)</code>。数组的扩容机制是：如果数组空间不足，会先开辟一块新的空间地址，将原来的数组复制到新的数组中。</p><p>2、链表</p><p>链表不需要开辟连续的内存空间，其通过指针将所有的数据连接起来。新增或者删除的时候只需要将指针指向的地址修改就行了，时间复杂度为 <code>O(1)</code>。但是查询的时间复杂度为 <code>O(n)</code>。</p><h2 id="二、链表" tabindex="-1"><a class="header-anchor" href="#二、链表"><span>二、链表</span></a></h2><p>1、双向链表</p><p><img src="'+s+`" alt="linked" loading="lazy"> 双向链表是各个节点之间的逻辑关系是双向的。<br> 双向链表中节点的组成是：<code>prior：</code> 指向当前节点的前置节点，<code>data：</code>当前节点存储的数据。<code>next：</code>指向当前节点的后置节点。</p><p>2、压缩链表</p><ul><li>压缩链表是为了节约内存开发的。</li><li>ziplist是一个特别的双向链表，没有维护双向指针prev next;反而是存储上一个entry的长度和当前entry长度，通过长度推算出下一个元素在什么地方。</li><li>牺牲读取的性能，获得高效的存储空间，因为存储指针比存储entry长度更费内存，这就是典型的时间换空间。</li></ul><p>3、quicklist链表</p><ul><li>官网介绍：</li></ul><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">    A</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> doubly linked list of ziplists</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">    A</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> generic doubly linked quicklist implementation</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>介绍:<br> quicklist是一个双向链表，并且是一个ziplist的双向链表，ziplist本身是一个维持数据项先后顺序的列表，而且数据项保存在一个连续的内存块种。</li></ul><h2 id="三、对比" tabindex="-1"><a class="header-anchor" href="#三、对比"><span>三、对比</span></a></h2><p>1、双向链表</p><ul><li>双端链表便于在表的两端进行push和pop操作，但是它的内存开销比较大。</li><li>双端链表每个节点上除了要保存的数据之外，还要额外保存两个指针。</li><li>双端链表的各个节点是单独的内存块，地址不连续，节点多了容易产生内存碎片。</li></ul><p>2、压缩列表</p><ul><li>ziplist由于是一块连续的内存，所以存储效率很高。</li><li>ziplist不利于修改操作，每次数据变动都会引发一次内存的realloc。</li><li>当ziplist长度很长的时候，一次realloc可能会导致大批量的数据拷贝，进一步降低性能。</li></ul><p>3、quicklist链表</p><ul><li>空间效率和时间效率的折中。</li><li>结合了双端链表和压缩列表的优点。</li></ul><h2 id="四、总结" tabindex="-1"><a class="header-anchor" href="#四、总结"><span>四、总结</span></a></h2><p>在 <code>redis 3.2</code> 版本之前使用的是 <code>双向链表和压缩链表</code> 两种，因为双向链表占用的内存要比压缩链表高，所以创建链表时首先会创建 <code>压缩链表</code>，在合适的时机会转化成<code>双向链表</code>。<code>redis 3.2</code> 之后使用的是 <code>quicklist链表</code>。</p>`,23)]))}const c=i(n,[["render",o],["__file","list.html.vue"]]),h=JSON.parse('{"path":"/database/redis/list.html","title":"【第八篇章】链表","lang":"zh-CN","frontmatter":{"title":"【第八篇章】链表","index":false,"isOriginal":true,"category":"数据库","tag":"redis","date":"2024-08-03T00:00:00.000Z","description":"一、数组和链表 1、数组 数组会在内存中开辟一块连续的空间存储数据，这种存储方式有利也有弊端。当获取数据的时候，直接通过下标值就可以获取到对应的元素，时间复杂度为 O(1)。但是如果新增或者删除数据会移动大量的数据，时间复杂度为 O(n)。数组的扩容机制是：如果数组空间不足，会先开辟一块新的空间地址，将原来的数组复制到新的数组中。 2、链表 链表不需要...","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/backend-book/database/redis/list.html"}],["meta",{"property":"og:site_name","content":"极速蜗牛"}],["meta",{"property":"og:title","content":"【第八篇章】链表"}],["meta",{"property":"og:description","content":"一、数组和链表 1、数组 数组会在内存中开辟一块连续的空间存储数据，这种存储方式有利也有弊端。当获取数据的时候，直接通过下标值就可以获取到对应的元素，时间复杂度为 O(1)。但是如果新增或者删除数据会移动大量的数据，时间复杂度为 O(n)。数组的扩容机制是：如果数组空间不足，会先开辟一块新的空间地址，将原来的数组复制到新的数组中。 2、链表 链表不需要..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-08-04T06:26:54.000Z"}],["meta",{"property":"article:author","content":"青衣"}],["meta",{"property":"article:tag","content":"redis"}],["meta",{"property":"article:published_time","content":"2024-08-03T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-08-04T06:26:54.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"【第八篇章】链表\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-08-03T00:00:00.000Z\\",\\"dateModified\\":\\"2024-08-04T06:26:54.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"青衣\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":2,"title":"一、数组和链表","slug":"一、数组和链表","link":"#一、数组和链表","children":[]},{"level":2,"title":"二、链表","slug":"二、链表","link":"#二、链表","children":[]},{"level":2,"title":"三、对比","slug":"三、对比","link":"#三、对比","children":[]},{"level":2,"title":"四、总结","slug":"四、总结","link":"#四、总结","children":[]}],"git":{"createdTime":1722752814000,"updatedTime":1722752814000,"contributors":[{"name":"Tsing","email":"ld320321@163.com","commits":1}]},"readingTime":{"minutes":2.69,"words":808},"filePathRelative":"database/redis/list.md","localizedDate":"2024年8月3日","excerpt":"<h2>一、数组和链表</h2>\\n<p>1、数组</p>\\n<p>数组会在内存中开辟一块连续的空间存储数据，这种存储方式有利也有弊端。当获取数据的时候，直接通过下标值就可以获取到对应的元素，时间复杂度为 <code>O(1)</code>。但是如果新增或者删除数据会移动大量的数据，时间复杂度为 <code>O(n)</code>。数组的扩容机制是：如果数组空间不足，会先开辟一块新的空间地址，将原来的数组复制到新的数组中。</p>\\n<p>2、链表</p>\\n<p>链表不需要开辟连续的内存空间，其通过指针将所有的数据连接起来。新增或者删除的时候只需要将指针指向的地址修改就行了，时间复杂度为 <code>O(1)</code>。但是查询的时间复杂度为 <code>O(n)</code>。</p>","autoDesc":true}');export{c as comp,h as data};
