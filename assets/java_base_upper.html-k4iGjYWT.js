import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,a as e,o as l}from"./app-Drd-A0J4.js";const t={};function n(h,i){return l(),a("div",null,i[0]||(i[0]=[e(`<h2 id="一、java-中有几种基本数据类型-各占多少字节" tabindex="-1"><a class="header-anchor" href="#一、java-中有几种基本数据类型-各占多少字节"><span>一、Java 中有几种基本数据类型？各占多少字节？</span></a></h2><p>在 Java 中基本数据类型有 8 个，占用的字节分别是整型 byte（1个字节）、short（2个字节）、int（4个字节）、long（8个字节）；浮点型 float（4个字节）、double（8个字节）；布尔类型 boolean； 字符类型 char (2个字节)。</p><h2 id="二、string-类能被继承吗-为什么" tabindex="-1"><a class="header-anchor" href="#二、string-类能被继承吗-为什么"><span>二、String 类能被继承吗？为什么？</span></a></h2><p>String 类不能被继承。因为 String 类被 final 修饰。final 修饰变量变量就会变成常量；final 修饰方法方法就会不可重写；final 修饰类类就不能继承；</p><h2 id="三、string、stringbuilder、stringbuffer-的区别" tabindex="-1"><a class="header-anchor" href="#三、string、stringbuilder、stringbuffer-的区别"><span>三、String、StringBuilder、StringBuffer 的区别？</span></a></h2><p>String 是只读字符串，也就是说 String 引用的字符串内容是不能被改变的。</p><p>StringBuffer/StringBuilder 类表示字符串对象可以直接修改。</p><p>StringBuffer 是线程安全的效率慢。StringBuilder 是线程不安全的效率高。</p><h2 id="四、在多线程情况下-simpledateformat-是线程安全的吗" tabindex="-1"><a class="header-anchor" href="#四、在多线程情况下-simpledateformat-是线程安全的吗"><span>四、在多线程情况下 SimpleDateFormat 是线程安全的吗？</span></a></h2><p>在多线程情况下 DateFormat 的所有实现，包括 SimpleDateFormat 都不是线程安全的。如果不在线程安全的情况下使用，在解析或者格式化日期的时候，可能会会获得一个不正确的结果。最佳的时间的多线程的情况下使用的时间工具类是 <code>joda-time</code>。</p><h2 id="五、equals-和-区别" tabindex="-1"><a class="header-anchor" href="#五、equals-和-区别"><span>五、equals 和 == 区别</span></a></h2><p><code>==</code> 比较的是变量（栈）内<code>equals</code> 和 <code>==</code> 在Java中的主要区别体现在以下几个方面：</p><h3 id="_1、本质区别" tabindex="-1"><a class="header-anchor" href="#_1、本质区别"><span>1、本质区别</span></a></h3><ul><li><strong>equals()</strong>：是定义在<code>java.lang.Object</code>类中的一个方法，用于比较两个对象的内容是否相等。它是一个方法，因此可以通过重写（Override）来改变其默认行为。</li><li><strong>==</strong>：是一个操作符，用于比较两个对象或基本数据类型的值是否相等。对于对象，它比较的是两个对象在内存中的地址是否相同，即是否是同一个对象的引用；对于基本数据类型，它比较的是两个值是否相等。</li></ul><h3 id="_2、比较内容" tabindex="-1"><a class="header-anchor" href="#_2、比较内容"><span>2、比较内容</span></a></h3><ul><li><strong>equals()</strong>：默认情况下，<code>equals()</code>方法通过<code>==</code>来比较两个对象的引用是否相同（即是否是同一个对象）。但是，许多类（如<code>String</code>、<code>Integer</code>等）都重写了<code>equals()</code>方法，以提供基于内容而非引用的比较。</li><li><strong>==</strong>：对于对象，它总是比较引用；对于基本数据类型，它比较的是值。</li></ul><h3 id="_3、灵活性" tabindex="-1"><a class="header-anchor" href="#_3、灵活性"><span>3、灵活性</span></a></h3><ul><li><strong>equals()</strong>：由于<code>equals()</code>是一个方法，因此它可以通过重写来提供灵活的比较逻辑。例如，在自定义类中，可以根据类的属性来定义两个对象何时被视为相等。</li><li><strong>==</strong>：其比较逻辑是固定的，无法更改。</li></ul><h3 id="_4、-性能" tabindex="-1"><a class="header-anchor" href="#_4、-性能"><span>4、 性能</span></a></h3><ul><li><strong>equals()</strong>：由于可能需要执行复杂的比较逻辑（特别是在重写了<code>equals()</code>方法的类中），因此其性能可能低于<code>==</code>。</li><li><strong>==</strong>：仅仅比较引用或值，因此其性能通常优于<code>equals()</code>。</li></ul><h3 id="_5、-使用场景" tabindex="-1"><a class="header-anchor" href="#_5、-使用场景"><span>5、 使用场景</span></a></h3><ul><li><strong>equals()</strong>：当需要比较两个对象的内容是否相等时，应使用<code>equals()</code>方法。特别是当比较的是自定义对象或已经重写了<code>equals()</code>方法的类（如<code>String</code>、<code>Integer</code>等）的实例时。</li><li><strong>==</strong>：当需要比较两个对象是否是同一个对象（即它们的引用是否相同）时，应使用<code>==</code>操作符。此外，对于基本数据类型的比较，也应使用<code>==</code>。</li></ul><h3 id="示例" tabindex="-1"><a class="header-anchor" href="#示例"><span>示例</span></a></h3><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> s1 </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> String</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;hello&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">String</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> s2 </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> String</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;hello&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">)</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">out</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(s1 </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">==</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> s2);</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // false，因为s1和s2虽然内容相同，但它们是两个不同的对象</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">out</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">s1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">equals</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(s2));</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // true，因为String类重写了equals()方法，以比较内容</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Integer</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> i1 </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 123</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Integer</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;"> i2 </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 123</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">out</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(i1 </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">==</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> i2);</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // true，对于Integer这样的包装类，在-128到127之间的值会被缓存，因此i1和i2实际上是同一个对象</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">System</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">out</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">println</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">i1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">equals</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(i2));</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // true，即使不考虑缓存，equals()方法也会比较值</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个示例中，<code>==</code>用于比较<code>String</code>对象时返回<code>false</code>，因为<code>s1</code>和<code>s2</code>虽然内容相同，但它们是两个不同的对象；而<code>equals()</code>方法返回<code>true</code>，因为<code>String</code>类重写了<code>equals()</code>方法以比较内容。对于<code>Integer</code>对象，由于Java对-128到127之间的值进行了缓存，因此<code>i1</code>和<code>i2</code>实际上是同一个对象，所以<code>==</code>和<code>equals()</code>都返回<code>true</code>。但即使不考虑缓存，<code>equals()</code>方法也会比较两个<code>Integer</code>对象的值是否相等。</p><h2 id="六、final-有哪些用法" tabindex="-1"><a class="header-anchor" href="#六、final-有哪些用法"><span>六、final 有哪些用法？</span></a></h2><ul><li>被 final 修饰的类不能被继承</li><li>被 final 修饰的方法不能被重写</li><li>被 final 修饰的变量不能被修改值</li><li>被 final 修饰的方法 jvm会尝试内联 以提高运行效率</li><li>被 final 修饰的常量，在编译阶段会存入常量池中</li></ul><h2 id="七、java-反射的作用原理" tabindex="-1"><a class="header-anchor" href="#七、java-反射的作用原理"><span>七、Java 反射的作用原理</span></a></h2><p>1、定义</p><p>反射机制是在运行时，对于任意一个类，都能知道这个类的所有属性和方法；对于任意个对象，都能调用它的任意一个方法。在 java 中只要给定类的名字，就可以通过反射机制来获得类的所有信息。</p><p>2、反射的实现方式</p><ul><li>使用类名的 <code>.class</code> 属性，例如 <code>String.class</code> 可以获取 <code>String</code> 类的 <code>Class</code> 对象。</li><li>使用对象的 <code>getClass()</code> 方法，例如 <code>&quot;hello&quot;.getClass()</code> 可以获取字符串对象的 <code>Class</code> 对象。</li><li>使用 <code>Class.forName()</code> 方法，需要传入类的全限定名，例如 <code>Class.forName(&quot;java.lang.String&quot;)</code>。</li></ul>`,32)]))}const p=s(t,[["render",n],["__file","java_base_upper.html.vue"]]),o=JSON.parse('{"path":"/interview/javabase/java_base_upper.html","title":"☕ Java基础面试题总结(上)","lang":"zh-CN","frontmatter":{"title":"☕ Java基础面试题总结(上)","index":false,"isOriginal":true,"category":"面试宝典","tag":"java","date":"2024-08-12T00:00:00.000Z","description":"一、Java 中有几种基本数据类型？各占多少字节？ 在 Java 中基本数据类型有 8 个，占用的字节分别是整型 byte（1个字节）、short（2个字节）、int（4个字节）、long（8个字节）；浮点型 float（4个字节）、double（8个字节）；布尔类型 boolean； 字符类型 char (2个字节)。 二、String 类能被继承吗...","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/backend-book/interview/javabase/java_base_upper.html"}],["meta",{"property":"og:site_name","content":"极速蜗牛"}],["meta",{"property":"og:title","content":"☕ Java基础面试题总结(上)"}],["meta",{"property":"og:description","content":"一、Java 中有几种基本数据类型？各占多少字节？ 在 Java 中基本数据类型有 8 个，占用的字节分别是整型 byte（1个字节）、short（2个字节）、int（4个字节）、long（8个字节）；浮点型 float（4个字节）、double（8个字节）；布尔类型 boolean； 字符类型 char (2个字节)。 二、String 类能被继承吗..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-08-22T09:49:20.000Z"}],["meta",{"property":"article:author","content":"青衣"}],["meta",{"property":"article:tag","content":"java"}],["meta",{"property":"article:published_time","content":"2024-08-12T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-08-22T09:49:20.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"☕ Java基础面试题总结(上)\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-08-12T00:00:00.000Z\\",\\"dateModified\\":\\"2024-08-22T09:49:20.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"青衣\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":2,"title":"一、Java 中有几种基本数据类型？各占多少字节？","slug":"一、java-中有几种基本数据类型-各占多少字节","link":"#一、java-中有几种基本数据类型-各占多少字节","children":[]},{"level":2,"title":"二、String 类能被继承吗？为什么？","slug":"二、string-类能被继承吗-为什么","link":"#二、string-类能被继承吗-为什么","children":[]},{"level":2,"title":"三、String、StringBuilder、StringBuffer 的区别？","slug":"三、string、stringbuilder、stringbuffer-的区别","link":"#三、string、stringbuilder、stringbuffer-的区别","children":[]},{"level":2,"title":"四、在多线程情况下 SimpleDateFormat 是线程安全的吗？","slug":"四、在多线程情况下-simpledateformat-是线程安全的吗","link":"#四、在多线程情况下-simpledateformat-是线程安全的吗","children":[]},{"level":2,"title":"五、equals 和 == 区别","slug":"五、equals-和-区别","link":"#五、equals-和-区别","children":[{"level":3,"title":"1、本质区别","slug":"_1、本质区别","link":"#_1、本质区别","children":[]},{"level":3,"title":"2、比较内容","slug":"_2、比较内容","link":"#_2、比较内容","children":[]},{"level":3,"title":"3、灵活性","slug":"_3、灵活性","link":"#_3、灵活性","children":[]},{"level":3,"title":"4、 性能","slug":"_4、-性能","link":"#_4、-性能","children":[]},{"level":3,"title":"5、 使用场景","slug":"_5、-使用场景","link":"#_5、-使用场景","children":[]},{"level":3,"title":"示例","slug":"示例","link":"#示例","children":[]}]},{"level":2,"title":"六、final 有哪些用法？","slug":"六、final-有哪些用法","link":"#六、final-有哪些用法","children":[]},{"level":2,"title":"七、Java 反射的作用原理","slug":"七、java-反射的作用原理","link":"#七、java-反射的作用原理","children":[]}],"git":{"createdTime":1723449753000,"updatedTime":1724320160000,"contributors":[{"name":"Tsing","email":"ld320321@163.com","commits":4}]},"readingTime":{"minutes":4.54,"words":1362},"filePathRelative":"interview/javabase/java_base_upper.md","localizedDate":"2024年8月12日","excerpt":"<h2>一、Java 中有几种基本数据类型？各占多少字节？</h2>\\n<p>在 Java 中基本数据类型有 8 个，占用的字节分别是整型 byte（1个字节）、short（2个字节）、int（4个字节）、long（8个字节）；浮点型 float（4个字节）、double（8个字节）；布尔类型 boolean； 字符类型 char (2个字节)。</p>\\n<h2>二、String 类能被继承吗？为什么？</h2>\\n<p>String 类不能被继承。因为 String 类被 final 修饰。final 修饰变量变量就会变成常量；final 修饰方法方法就会不可重写；final 修饰类类就不能继承；</p>","autoDesc":true}');export{p as comp,o as data};
